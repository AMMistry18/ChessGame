# ChessGame
#### Video Demo: https://youtu.be/hRXoEhOvKc4
#### Description:
I designed the project as a complete implementation of chess using Java and Swing for the graphical interface. The aim was to provide a fully playable chess game enforcing all standard rules of chess with an intuitive user interface for two players to enjoy the classic game. The Chess class is a simple class serving as the entry point into my program, and that is where I have set up the game window using JFrame and implemented a mouse interaction system. I extend MouseAdapter to handle the selection and movement of pieces; clicking a piece first selects it-highlighting it with a yellow border-and then a subsequent click moves the piece if it's a valid move. Capture logic checks if a target square contains an opponent's piece and removes it from play if captured. I did this in such a way that it works intuitively: one cannot select an opponent's piece on their turn, and one can only capture opponent pieces, not one's own.
Most of the core functionality resides within this GamePanel class. I did manage to implement a game loop running at 60 FPS, hence continuous rendering and updating states of the game. In all probability, the most complex feature I built was the check detection system: continuously check the state of the board if either king is under attack. I have implemented checkmate detection: checking if the king has any legal moves left and checking if any pieces can block the check. In order to handle stalemate situations, I have written the logic that checks if there is some legitimate move available for a player and no situation in which he would be in check. The pawn promotion system displays a JOptionPane dialog to let the players choose with which piece to promote when it reaches the other end of the board.
In regard to the pieces themselves, I have a parent class Piece to handle functionality that is the same across pieces. Within here, I implemented two significant methods of validation-checkRook and checkBishop-which I could use within other pieces to verify moves. For example, the Queen uses both since it combines both Rook and Bishop movements. Each of the piece types (Pawn, Rook, Knight, Bishop, Queen, King) extends the base class and implements its way of movement.
The special moves of the game-like castling were captured by the King class, which at first checks if the king and the selected rook are not moved. Then it checks if all of the squares in between them are free before making the castle move. All the special rules considering pawns are covered, such as an initial two-square move, capturing diagonally, en passant capture (the way a pawn captures through, after an opponent's pawn has made a two-square advance), and promotion. All of these are covered in the checkRules method of the pawn.
The Board class simply represents the chessboard itself. I decided on a deep burgundy (in RGB: 155, 53, 61) and black for the squares, giving it that real chessboard feel. Board drawing logic simply uses a nested loop, flipping between these two colors and filling each 100x100 pixel square to build the 8x8 grid.
Movement of pieces is checked on a multilevel setup to start: basic piece pattern of movement-for instance, knights only moving in a specific L-shaped pattern, bishops only moving in a diagonal fashion. Then it checks if pieces cannot move through other pieces-except, of course, for knights. Finally, check if your moves do not leave or put your own king in check. The latter I implemented as a canBlock and canCause system where the moves are simulated temporarily to see their effect on the king not being in check.
State management was a fun challenge. I did use static methods for the functions that needed to access the state of the board globally, such as getPieceAt and update, but kept piece-specific logic instance-based. This allowed me to track the state of the game easily and deal with interactions between pieces while still keeping clean, readable code.
To represent the pieces visually, I implemented a system of image loading in which each piece loads its corresponding PNG file based on its color at initialization. That could have been centralized, but it seemed like leaving the image loading with each piece class made for more maintainable code and made it easier to alter the appearance of any one piece.
The movement update system works by first checking a move through a bunch of different checks: basic piece rules, collision detection, check prevention, special move conditions. Once a move is found valid, the piece updates its position, and then any special moves, like castling or pawn promotion, are handled. After each move, it switches to the other player's turn, then checks for check, checkmate, or stalemate conditions.
Speaking of new feature ideas, I have really thought about many other additions that could enhance this game. Move history would go a long way in reviewing the game and probably implementing an 'undo' feature later on. Network multiplayer support would add the ability to play against other people online. Adding an AI opponent with usual chess algorithms would enable single-player games. Also, the addition of a timer system for chess clocks and a move suggestion system for beginners will make the game far more versatile in terms of different skills and formats of the game.
